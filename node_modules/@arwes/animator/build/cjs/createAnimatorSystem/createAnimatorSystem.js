"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAnimatorSystem = void 0;
const tools_1 = require("@arwes/tools");
// TODO: Animator with "combine" should have its duration as the total duration
// of its children's durations.
// TODO: The scheduling right now is as follows:
// 1. Animator setup node
// 2. System create node
// 3. System schedules node setup
// 3. Animator schedules control change
// 3. Component subscribes to node
// 4. System node setup
// 5. System node transition
// 6. Machine run control change
// 6. System node transitions if applicable
// The sequence of events is not playing with the React scheduling system.
// And the initial schedules (setup and change) complicates the system.
// There should be a simpler way to sync with the React system to setup and
// properly detect for control changes for transitions.
const createAnimatorSystem = () => {
    let idCounter = 0;
    let root;
    const createNode = (parent, control) => {
        const { machine } = control.getSettings();
        if (!machine) {
            throw new Error('A machine is required to create an animator node.');
        }
        const id = idCounter++;
        let node; // eslint-disable-line prefer-const
        let state = '';
        const transition = (newState) => {
            var _a;
            if (state === newState) {
                return;
            }
            state = newState;
            const nodeScoped = node;
            const { onEntry } = machine.states[state] || {};
            const { onTransition } = control.getSettings();
            if (onEntry === null || onEntry === void 0 ? void 0 : onEntry.execute) {
                onEntry.execute(nodeScoped);
            }
            if (onEntry === null || onEntry === void 0 ? void 0 : onEntry.schedule) {
                const task = onEntry.schedule(nodeScoped);
                if (!Number.isFinite(task.duration) || task.duration < 0 || !task.action.length) {
                    throw new Error('Machine state schedule must return a valid duration and action name.');
                }
                nodeScoped.scheduler.start(task.duration, () => send(task.action));
            }
            (_a = machine.onTransition) === null || _a === void 0 ? void 0 : _a.call(machine, nodeScoped);
            onTransition === null || onTransition === void 0 ? void 0 : onTransition(nodeScoped);
            for (const subscriber of nodeScoped.subscribers) {
                subscriber(nodeScoped);
            }
        };
        const send = (action) => {
            var _a, _b;
            const newState = (_b = (_a = machine.states[state]) === null || _a === void 0 ? void 0 : _a.onActions) === null || _b === void 0 ? void 0 : _b[action];
            if (newState) {
                transition(newState);
            }
        };
        const onSettingsChange = () => {
            const nodeScoped = node;
            // Schedule after React useEffects have taken effect so the potential
            // subscribers have been subscribed and the node setup has been done.
            nodeScoped.scheduler.start('change', 0.001, () => {
                var _a;
                (_a = machine.onSettingsChange) === null || _a === void 0 ? void 0 : _a.call(machine, nodeScoped);
            });
        };
        node = Object.freeze({
            id,
            control,
            parent,
            children: new Set(),
            subscribers: new Set(),
            scheduler: (0, tools_1.createTOScheduler)(),
            context: {},
            getState: () => state,
            send,
            onSettingsChange
        });
        if (parent) {
            parent.children.add(node);
        }
        if (tools_1.TOOLS_IS_BROWSER) {
            // Schedule after React useEffects have taken effect so the potential
            // subscribers have been subscribed and before any node change.
            node.scheduler.start('setup', 0.001, () => {
                var _a, _b;
                const nodeScoped = node;
                (_a = machine.onCreate) === null || _a === void 0 ? void 0 : _a.call(machine, nodeScoped);
                transition(machine.initialState);
                (_b = machine.onInitialTransition) === null || _b === void 0 ? void 0 : _b.call(machine, nodeScoped);
            });
        }
        return node;
    };
    const removeNode = (node) => {
        node.scheduler.stopAll();
        for (const child of node.children) {
            removeNode(child);
        }
        if (node.parent) {
            node.parent.children.delete(node);
        }
        node.children.clear();
        node.subscribers.clear();
    };
    const unregister = (node) => {
        if (!root) {
            return;
        }
        removeNode(node);
        if (root.id === node.id) {
            root = undefined;
        }
    };
    const setup = (control) => {
        if (root) {
            removeNode(root);
        }
        root = createNode(undefined, control);
        return root;
    };
    const register = (parent, control) => {
        if (!root) {
            throw new Error('A root node needs to be setup before registering nodes.');
        }
        return createNode(parent, control);
    };
    return Object.freeze({ setup, register, unregister });
};
exports.createAnimatorSystem = createAnimatorSystem;
